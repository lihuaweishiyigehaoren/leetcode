### 字节跳动问题

### C++

#### static/extern/inline关键字详解

1.static 

全局变量与静态全局变量的区别

全局变量前面加上static就是静态全局变量.全局变量和静态全局变量都是静态存储方式.两者的主要区别是**非静态全局变量的作用域是整个源程序,当一个源程序由多个源文件组成时,非静态的全局变量在各个源文件中都是有效的.**  而**静态全局变量则限制其作用域,只在定义该变量的源文件内有效,在同一源程序的其他源文件中不能使用.**

总结:**把局部变量改变为静态变量后是改变了它的存储方式,即改变了它的生存期.把全局变量改变为静态变量后是改变了它的作用域,限制了它的使用范围**



普通函数和静态函数

static函数与普通函数**作用域不同**,静态函数只在本文件,只有在**当前源文件中使用的函数应该说明为内部函数(static),静态函数应该在当前文件中说明和定义.**对于可在当前源文件以外使用的函数,应该在一个头文件中声明,要使用这些函数的源文件要包含这个头文件.



static全局变量和普通的全局变量区别

static全局变量只初始化一次,防止在其他文件单元中被引用



static局部变量和普通局部变量区别

static局部变量只被初始化一次,下一次依据上一次的结果值



static函数与普通函数区别

static函数在内存中只有一份,普通函数在每个调用中维持一份拷贝



2.extern 外编译

extern全局变量(用extern修饰的变量只是说明**该变量在其他地方定义**，所以在其他地方一定要用明确的定义如int a，并且不能用static修饰）、**static全局变量和static局部变量的生存期都是“永久”，区别只是可见域不同。extern全局变量可见区域是工程，static全局变量可见区域是文件，而static局部变量的可见区域是块**。

从代码维护角度来看，对extern变量的修改可能会影响所有代码，对static全局变量的修改可能影响一个文件中的代码，而对static变量的修改可能影响一个块的代码；因此在选择变量类型时，优先级是static局部>static全局>extern全局。但它们有着共同的缺点：使用了这些类型变量的函数将是不可重入的，不是线程安全的。在C/C++标准库中有很多函数都使用了static局部变量，目前的实现中都为它们提供了两套代码，单线程版本使用static变量而多线程版本使用“线程全局变量”，比如rand,strtok等。



**函数默认的修饰是extren,static把它声明为内部函数**



3.inline

优点:简单的说,内联函数直接将**函数替换到调用的位置**,这样可以大大的省掉调用函数的性能损失

缺点:程序体积变大,不利于动态升级,不利于调试



#### 智能指针问题?

auto_ptr 控制复制,赋值,构造,析构,解引用 转移对象所有权

后面还有引用计数的一些实现细节

https://blog.csdn.net/albertsh/article/details/82286999



#### 类成员变量的声明顺序和初始化顺序

#### 讲讲C++多态(封装,继承)

通过继承，一个类可以被当作不止一个数据类型（type）使用，它可以被用做自身代表的数据类型（这是最常用的），还可以被当作它的任意基类所代表的数据类型，乃至任意接口类型--前提是这个类实现了这个接口。这一机制称为"多态"

#### 讲讲C++的内存布局

1.类成员变量的声明顺序和初始化顺序

2.普通成员变量按照声明顺序存放,内存对齐,较晚出现的成员在class对象中有较高的地址

3.讲讲静态成员函数 在data segment 

4.虚函数表指针

#### 虚函数表存了什么信息

1.type_info for Point(类)最前面

2.虚函数

 // 父类指向子类(对象) 会发生切割行为

#### 出现菱形继承虚继承时C++对象内存布局 ,sizeof这个类的结果是多少

虚继承只有一个实例

#### 一个C++程序执行main函数前和执行完main函数后发生什么

总结：
[main函数](https://www.baidu.com/s?wd=main%E5%87%BD%E6%95%B0&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)执行之前，主要就是[初始化](https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)系统相关资源：
1.设置栈指针
2.[初始化](https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)static静态和global全局变量，即data段的内容  // data段落
3.将未[初始化](https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.[bss段](https://www.baidu.com/s?wd=bss%E6%AE%B5&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的内容
4.运行全局构造器，估计是[C++](https://www.baidu.com/s?wd=C%2B%2B&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)中[构造函数](https://www.baidu.com/s?wd=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)之类的吧
5.将[main函数](https://www.baidu.com/s?wd=main%E5%87%BD%E6%95%B0&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的参数，argc，argv等传递给[main函数](https://www.baidu.com/s?wd=main%E5%87%BD%E6%95%B0&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，然后才真正运行main函数

main 函数之后会执行相反的工作。

#### do{}while(0)为什么要这样

https://www.jianshu.com/p/99efda8dfec9

作用:

1.宏定义时,如果是多个语句的宏,在展开的时候可能会出错

2.可以避免goto语句,异常时退出循环即可

3.避免空宏引起的警告

4.可以定义单一函数快速完成特定操作,且其间局部变量名不影响其他



### 操作系统

#### 操作系统的一些调度算法

多任务系统划分两类:非抢占式任务和抢占式多任务.(进程优先级和时间片)

linux调度算法 : -记住这个-用红黑树存储进程的  **完全公平调度(CFS)**

**实时调度策略** -不用时间片

#### 段 ,页和区的区别

页-内核把物理页作为内存管理的基本单位,尽管处理器的最小寻址单位是字(甚至字节).但是内存管理单元(MMU,管理内存并把虚拟地址转换为物理地址的硬件)通常以页为单位进行处理.正因为如此,MMU以页大小为单位来管理系统中的页表,从虚拟内存的角度而言,页就是最小单位.32位系统通常支持4kb的页,64位一般会支持8kb的页.(摘自12.1)

区-由于硬件的限制,内核并不能对所有的页一视同仁,有些页位于内存中特定的物理地址上,所以不能将其用于一些特定的任务.由于存在这种限制,所以内核把页划分为不同的区,内核使用区对具有相似特征的页进行分组.

直接执行DMA的区,-直接寻址等

内核虚拟内存的某些区域被映射到所有进程共享的物理页面。

linux将虚拟内存组织成一些区域（也叫作段)的集合。一个段就是已经 存在着的（已分配）虚拟内存的连续片，这些页是一某种方式相关联的。

#### 进程和线程切换的时候会发生什么

<https://blog.csdn.net/qq_39975542/article/details/81605101>

这里讲的真好

#### 讲讲协程，如果让你实现一个协程库,你会怎么实现

用户实现手动切换

申请一块内存来模拟栈

#### 实现一个线程池

#### 讲讲mmap的实现原理

#### 你用C++一般怎么读写文件,在这种方式下,如果你在读写文件时程序挂了,那么会发生什么

#### 用户态内核态

<https://www.cnblogs.com/maxigang/p/9041080.html>

#### 内存.外存,虚拟内存,物理内存.高速缓存

#### 页面置换算法有哪些

LRU

#### 操作系统底层的内存分配管理

必须要理解虚拟内存和内存映射

**fork()函数**-fork函数在当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的pid，为了给这个新进程创建虚拟内存，它创建了当前进程mm_struct、区域结构和页表的原样副本，它将两个进程中的每个页面标记为只读，并将两个进程中的每个区域结构都标记为**私有的写时复制**。也就为每个进程保持了私有地址空间的抽象概念。

**execve()**-在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out程序有效的替代了当前程序。加载有如下步骤：

1.删除已经存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构

2.映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为a.out文件的.text和.data区。bss区域是请求二进制0的，映射到匿名文件，其大小包含所在a.out中，栈和堆区域也是请求二进制0的，初始长度为0.

3.映射共享区域。如果a.out程序与共享对象（或目标）链接，比如C库中的libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内

4.设置程序计数器，设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。

**mmap()**-创建新的虚拟内存区域，并将对象映射到这些区域中，munmap函数删除虚拟内存区域

**malloc()**-动态内存分配器，维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配供应用程序使用，空闲块可用来分配。

sbrk()-指向堆顶。

brk(),sbrk(),mmap(),ptmalloc(),emalloc()(注意区别库函数) 

sbrk是C函数,系统调用brk和mmap,具体根据分配大小加以区分,sbrk调用brk

#### fwrite()调用会刷回磁盘吗?如果成功调用结束程序会刷回吗

不会:缓冲IO,会(面试官讲的,可能题目意思是成功返回,返程就是调用了fclose,主动刷)



#### 怎么查看linux哪个进程打开了哪些文件？

isof

https://www.cnblogs.com/bonelee/p/7735479.html

#### epoll底层实现

https://www.cnblogs.com/charlesblc/p/6242479.ht



#### linux阻塞和非阻塞是怎么体现的



### 网络编程

#### TCP的三次握手机制你觉得会出现什么安全上的问题

https://wenku.baidu.com/view/656c5fbcaa00b52acec7ca1a.html

dos攻击 拒绝服务攻击 - 1.伪装虚假ip地址发动攻击 2.拦截客户机应答报文

在TCP三次握手时插入伪造TCP包

#### 对DDos了解吗?讲讲你所知道的DDos攻击方式以及防护措施

https://www.365blogs.com/seoanli/819.html

https://baijiahao.baidu.com/s?id=1609028355233889214&wfr=spider&for=pc

#### 讲讲你所知道的套接字选项

SO_REUSEADDR-端口可重用

TCP_NODELAY-设置1禁用Nagle算法

#### 讲讲select,poll,epoll的实现原理

**https://blog.csdn.net/nanxiaotao/article/details/90612404**

#### http2.0新特性,了解http3.0吗

#### 讲讲https的握手,和http相比,https有什么优缺点

#### 分布式一致性算法

<https://blog.csdn.net/wuxians/article/details/81275441>

两段提交,三段提交,Paxos,raft,gossip

#### HTTP头部字段

https://www.cnblogs.com/chenxizhaolu/p/7591549.html

#### HTTP请求方式有哪些？都有什么区别

https://www.cnblogs.com/cp168168/p/7923227.html



#### HTTP头部包含二进制不

处理HTTP协议的程序只关心 HTTP头是什么，不关心后面的数据是什么，所以他只要能够正确解析HTTP头里面的东西就可以了。其后面的数据是什么不是HTTP协议关心东西，所以处理HTTP协议的程序根本不会解析HTTP报文的其他部分，HTTP协议只会解析数据到两个连续的换行回车之前。后面的数据，像是HTML，exe等都不是HTTP协议负责解析的。

HTTP头其实就是ACSII码，准确的来说HTTP头里面不会出现标准ACSII之外的字符。URL里的中文一般都是用UTF-8编码，然后写成`%XX`的形式。所以HTTP里面不会出现标准ACSII之外的字符，所以HTTP头用ACSII编码就够了。这样就可以正确解析 HTTP头了。

然后就是使用HTTP传输数据的问题。其实数据的所有表现形式就都是二进制，在HTTP协议里面，传输需要的就是HTTP头，其后面携带的是什么数据都没有关系，对HTTP协议来说都是一样的。HTTP协议其后的数据是什么意思全看你上层怎么解释。HTTP协议传输数据就是 “HTTP头” `++` “数据”， HTTP协议只关心这个 HTTP头，数据格式那是上层应用关心的事情，是你自己的上层协议规定的格式，只要HTTP能够传输任意的二进制数据就可以了。HTTP头里面的`content-type`只是用于告诉处理HTTP协议的程序把这个数据交给上一层的哪个应用处理。比如在浏览器里，text/html 就交给处理HTML的程序处理，image/jpeg 就交给jpg的解码器，如果是application/octet-stream就交给下载程序处理等等。交给上层的数据，就是原始的HTTP报文里面两个连续的换行回车之后的数据，原封不动的数据。上层的处理程序能不能正确的识别“编码”，就不是HTTP所关心的了。

如果你把他们看作一个整体来看，显然是不行的。比如HTTP下一层是TCP？IP协议，难道TCP知道传输的网页使用UTF-8编码？不，他不知道，因为他不需要知道，他只需要把它携带的数据交给处理HTTP协议的程序就好了（TCP协议头里面也有一个标识上层协议的字段），所以你现在看到的数据不包含一些端口号 IP地址之类的东西。



#### HTTP与HTTPS的区别

https://baijiahao.baidu.com/s?id=1629455363537331894&wfr=spider&for=pc

#### HTTPS的安全外壳是怎么实现的

https://www.cnblogs.com/-new/p/7663746.html







### 数据结构

#### B树 B+树

<https://blog.csdn.net/yu876876/article/details/84896789>

B树看数据结构书-关键点：内存与磁盘是二级缓存，数据传输是IO操作，B树**关键码**为m，则只需要加载logmN次，这也是查找复杂度。降低了树高。优化了log2N。**插入删除原理**

1）B+树的磁盘读写代价更低

因为B+树内部结点没有指向关键字具体信息的指针，内部结点相对B树小
2）B+树的查询更加稳定

因为非终端结点并不是指向文件内容的结点，仅仅是作为叶子结点的关键字索引，因此所有的关键字查询都会走一条从根节点到叶子结点的路径。即s所有关键字查询的长度是一样的，查询效率稳定

####  map怎么实现的?讲讲红黑树的实现原理

#### 了解过跳表吗.rope知道吗



### 数据库

#### B+树节点页与页之间内存是连续的吗

数据库中一个io操作的基本单位叫做页（page）

https://blog.csdn.net/weixin_34075268/article/details/89078935?tdsourcetag=s_pcqq_aiomsg

#### 为什么索引要用B+树而不用红黑树呢

https://blog.csdn.net/buyulian/article/details/77996253

#### innoDB和MyISAM里面索引的设计有什么不同？比较一下

https://blog.csdn.net/ljfphp/article/details/80029968

#### redis跳跃表

随机掷骰子确定层数



#### 数据库的隔离级别

https://blog.csdn.net/weixin_39651041/article/details/79980202



#### B B+树

#### ACID特性

#### 索引



### 算法

#### 多个有序数组，N个有序数组，每个数组长度为M，合并该怎么做

1、采用小顶堆，然后首先取出每个数组的第一个元素来构建小顶堆

2、小顶堆构建完成之后将堆顶的元素排在排序数组中

3、取出和堆顶元素在一个数组中的下一个元素放到小顶堆中，并调整堆

4、重复上述三个步骤（上述步骤总共执行M*N次）



#### LRU

#### 链表快排

#### 给定一棵树,求树上距离为k的节点对的个数,如果多次询问有什么比较好的做法

#### 输入一个数字流,实时的显示当前已输入数字刘的中位数,你会怎么做

#### 最长不重复子串

#### 链表求公共节点

#### 正负数个数相同的数组转成正负交替数组,O(1)空间复杂度

#### 一个不均匀的硬币,正面的概率是p,反面的是1-p,要求出一个对等概率

正反两两一组,不是正反的丢弃,这样每个都是0.5

#### 现在有一个可以随机数1-9的均匀随机函数，要求推到出一个1-7的均匀随机函数

（8，9丢掉，2/9平摊给剩下的7个，再随机，2/9*1/9。。。）（三面被问到如果一直是生成9呢，一直丢弃怎么办？工程和数学不一样，不能做到准精度，只要在N次之后达到可接受的精度就可以做出取舍) 

#### 现在有一个可以随机数1-9的均匀随机函数，要求推到出一个1-13的均匀随机函数

（评论区大佬说的 ，先丢掉9，8个平分成4，4，之后再随机一个数，这样扩展到18，多的同上述，扔掉。）  

#### 有7个球，其中一个不质量不等，有一个天平，找出那个不等的球的比较次数

（最小1次最多3次，33分；22分最少2次最多3次

