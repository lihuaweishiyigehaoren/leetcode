### 网络

IP属于网络层，TCP属于传输层（传输层在网络成之上）

1、TCP/UDP的区别

回答：TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。UDP是一种不可靠的、无连接和基于数据（报文）的传输层通信协议。

对比表：

|              | TCP                                                          | UDP                                                          |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 协议类型     | 基于连接的协议，收发数据之前必须建立可靠连接，连接时需要三次握手 | 无连接协议，传输数据时源端和终端不需要建立连接               |
| 对资源要求   | 需要建立并维护连接，记录收发状态，以及缓存数据，因此需要资源较多 | 不需要建立维护连接状态，所需资源较少                         |
| 数据传输模式 | 流模式，将数据收发视为字节流，会自动进行IP数据包的拆分和组装 | 数据报文模式，在IP报文之上没有进行流的抽象，需要用户自拆分组装数据包 |
| 可靠性       | 可靠的连接，确保数据的正确性和完整性，确保传输顺序           | 不可靠的传输。不确保数据传输完整性，可能丢包。不确保数据到达的顺序 |

2、TCP三次握手、四次挥手

回答：三次握手：

（1）第一次握手：建立连接时，客户端发送SYN包（syn=j)到服务器，并进如SYN_SENT状态，等待服务器确认；SYN-同步序列编号

（2）第二次握手：服务器收到SYN包，必须确认客户端的SYN（ack=j+1)，同时自己也发送一个SYN包（syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态

（3）第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手

四次挥手：

（1）第一次分手：主机1（可以是客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number,向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态，表示主机1没有数据要发送给主机2。

（2）第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回复一个ACK报文段，Acknowledgment Number为Sequence Number加1,；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求

（3）第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态

（4）第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以进入关闭连接了。

与socket的联系：<https://www.cnblogs.com/suntp/p/6434644.html>

close并不是关闭连接，只有套接字对应的文件描述符引用计数为0 才会fin 强行fin 应该是用shutdown

3、HTTP由哪几部分组成

HTTP基于TCP，其实就是一组请求和响应，与此相对的，HTTP消息分为请求消息和响应消息。消息都分为消息头和消息体两部分，消息体可以是任何形式的数据。请求头中（Host表示资源的主机号和端口号，Referer用于指定URI资源地址，User-Agent用于存储表示客户端类型与版本的字符串。而在响应头中有用于重定向的Location和表示服务器类型版本的server等。

4、I/O模型

异步输入输出的思路如下：

（1）接收请求和输入输出不引起阻塞，无论什么情况都会立即返回。

（2）如果没有输入，返回一个特殊返回值提醒服务器下次继续尝试。

（3）如果输出失败，返回一个特殊返回值提醒服务器下次继续尝试。

5、epoll水平触发/边沿触发

epoll分为两种工作方式LT和ET。

LT(level triggered) 是默认/缺省的工作方式，同时支持 block和no_block socket。这种工作方式下，内核会通知你一个fd是否就绪，然后才可以对这个就绪的fd进行I/O操作。就算你没有任何操作，系统还是会继续提示fd已经就绪，不过这种工作方式出错会比较小，传统的select/poll就是这种工作方式的代表。

ET(edge-triggered) 是高速工作方式，仅支持no_block socket，这种工作方式下，当fd从未就绪变为就绪时，内核会通知fd已经就绪，并且内核认为你知道该fd已经就绪，不会再次通知了，除非因为某些操作导致fd就绪状态发生变化。如果一直不对这个fd进行I/O操作，导致fd变为未就绪时，内核同样不会发送更多的通知，因为only once。所以这种方式下，出错率比较高，需要增加一些检测程序。

**LT可以理解为水平触发，只要有数据可以读，不管怎样都会通知。而ET为边缘触发，只有状态发生变化时才会通知，可以理解为电平变化**。

6、TCP/UDP数据包最大长度限制

<https://blog.csdn.net/hellozhxy/article/details/80280197>

### C++

1、虚函数实现

回答：虚函数表，动态联编，执行的时候材质到

2、vector、list的区别

3、红黑树、hash表区别

回答：红黑树是有序的，Hash是无序的，根据需求来选择。

红黑树占用的内存更小（仅需要为其存在的节点分配内存），而Hash事先就应该分配足够的内存存储散列表（即使有些槽可能遭弃用）。

红黑树查找和删除的时间复杂度都是O(logn)，Hash查找和删除的时间复杂度都是O(1)。

4、hash表解决冲突的方法

链接法、开放定址法、桶地址法、建立公共溢出区

5、快排避免恶化方法

<https://www.jianshu.com/p/d6f96ae9dae4>

6、C++定位内存泄漏

#### 线程安全的单例模式

```c++
// 非线程安全的单例模式
class Singleton {
private:
    Singleton() {}
    ~Singleton() {}

public:
    //懒汉式以时间换空间
    Singleton* getInstance() {
        if(single == NULL) {
            single = new Singleton();
        }
        return &single;
    }

private:
    Singleton * single;
};

// 饿汉式是以空间换时间
class Singleton {
private:
    Singleton() {}
    ~Singleton() {}

public:
    Singleton* getInstance() {
        static Singleton single;
        return &single;
    }
};
```



```c++
// 线程安全的单例模式-效率低下
class Singleton {
private:
    Singleton() {}
    ~Singleton() {}

public:
    Singleton* getInstance() {
        std::lock_guard<std::mutex> lk(mutex1);
        if(single == NULL) {
            single = new Singleton();
        }
        return &single;
    }

private:
    Singleton * single;
    std::mutex mutex1;
};

// 优化版本-双重校验 -减少两个线程访问的加锁机制
    Singleton* getInstance() {
        if(single == NULL) {
            std::lock_guard<std::mutex> lk(mutex1);
            if(single == NULL) {
                single = new Singleton();
            }
        }
        return &single;
    }
```

https://www.jianshu.com/p/d8f2689e6352



#### UTF8和GD2312的区别

用最易懂的说法就是UTF-8里包括GB2312。UTF-8是国际通用的标准（包括世界所有的语言），而GB2312（只是简体中文）只适合做中文的网站。假设你想做个中文网页，但是还可以翻成英文的话，就得用UTF-8。如果用GB2312做的话，只能给中国人看看拉。

#### 一个汉字在GD2312是几个字节表示的

常用中文字符用utf-8编码占用3个字节（大约2万多字），但超大字符集中的更大多数汉字要占4个字节（在unicode编码体系中，U+20000开始有5万多汉字）。
GBK、GB2312收编的汉字占2个字节，严格地用iso8859-1无法表示汉字，只能转为问号。

#### linux进程栈和堆的空间如何分配和释放的

关于进程栈和线程栈总结：

​    （1）进程栈大小时执行时确定的，与编译链接无关

​    （2）进程栈大小是随机确认的，至少比线程栈要大，但不会超过2倍

​    （3）线程栈是固定大小的，可以使用ulimit -a 查看，使用ulimit -s 修改

​    （4）一般默认情况下，线程栈是在进程的堆中分配栈空间，每个线程拥有独立的栈空间，为了避免线程之间的栈空间踩踏，线程栈之间还会有以小块guardsize用来隔离保护各自的栈空间，一旦另一个线程踏入到这个隔离区，就会引发段错误。

#### 进程栈和线程栈的区别

<https://www.cnblogs.com/xzzzh/p/6596982.html>

#### 线程栈是在哪里分配的

堆

#### malloc的内存分配方式

<https://blog.csdn.net/a1299600490/article/details/77164843>

#### 指针失效问题如何解决

智能指针，或者delete赋空值

#### 模板特化

<https://www.cnblogs.com/dongzhiquan/p/7726379.html>

#### 定位内存泄漏

<https://blog.csdn.net/ydyang1126/article/details/72667411>

#### C语言怎么进行函数调用，参数压栈顺序，如何处理返回值



### 数据库

#### 一个场景：现在数据库执行过长，如何对它进行优化

https://blog.csdn.net/yzllz001/article/details/54848513

#### 简单谈一下数据库中的悲观锁和乐观锁是怎么理解的

https://www.jb51.net/article/155928.htm

#### 数据库有哪些索引类型，有什么优缺点

https://www.php.cn/mysql-tutorials-407751.html

普通索引，唯一索引，主键索引，组合索引

#### 数据库的事务

https://blog.csdn.net/l1394049664/article/details/81814090



### 操作系统

#### 什么是死锁，死锁产生有哪些条件？

死锁产生的四个条件（有一个条件不成立，则不会产生死锁）

互斥条件：一个资源一次只能被一个进程使用
请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

#### 用户态和内核态区别

https://www.jianshu.com/p/85e931636f27

#### 守护进程、僵尸进程、孤儿进程，守护进程的作用是什么？

#### 协程

#### 一个文件被删除了，没有被释放是什么原因

#### 弱类型、强类型、动态类型是什么

#### 自旋锁

#### 进程栈和线程栈的区别

#### OPEN、READ、WRITE的过程

#### 操作系统是如何调度进程呢

#### 消息队列

#### malloc的实现原理

#### 死锁的原因？条件？如何预防？又如何避免？如何解除？

#### 伙伴算法和slab算法

#### 线程是如何绑定到具体的cpu

<https://www.cnblogs.com/xiaojianliu/p/9689412.html>

#### 什么是解绑？实现方式？

#### 进程的调度算法



### 网络

#### tcp协议有哪些计时器？它分别是做什么的？

超时重传定时器、坚持定时器、保活定时器、时间等待定时器

https://www.cnblogs.com/yinbiao/p/11014949.html

#### 字节序与网络字节序

#### 超时重传，快速重传

#### 客户端服务器通信死锁如何处理

#### 长连接与短连接

#### HTTPS建立连接的过程

#### 常用的HTTP请求头与响应头

#### TCP如何保证有序传输的

#### 拥塞算法的改进

#### POST可以获取数据吗？就是实现GET方法？



#### redis是通过什么方式进行持久化的

RDB和AOP

https://www.cnblogs.com/AndyAo/p/8135980.html





### 算法

#### 二叉树公共祖先，只有root和左右节点